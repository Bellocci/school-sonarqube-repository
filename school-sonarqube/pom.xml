<project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  
  <groupId>com.examples</groupId>
  <artifactId>school-sonarqube</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>
  
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <!-- Dependency version -->
    <junit.version>4.13.1</junit.version>
    <assertj.swing.version>3.9.2</assertj.swing.version>
    <mockito.version>3.2.4</mockito.version>
    <mongo.version>3.12.1</mongo.version>
    <logback.version>1.2.3</logback.version>
    <mongojavaserver.version>1.24.0</mongojavaserver.version>
    <testcontainers.version>1.15.1</testcontainers.version>
    <picocli.version>3.9.3</picocli.version>
    <!-- plugin version -->
    <buildhelper.version>3.0.0</buildhelper.version>
    <failsafe.version>2.22.1</failsafe.version>
    <docker.version>0.34.1</docker.version>
    <jacoco.version>0.8.5</jacoco.version>
    <sonar.maven.version>3.8.0.2131</sonar.maven.version>
    
    <!-- SonarQube properties -->
    
    <!-- For each rule to be ignore, add another eXX and two corresponding
		 properties with eXX in the name as below -->
	<sonar.issue.ignore.multicriteria>e11,e12,e13</sonar.issue.ignore.multicriteria>
	<!-- Disable rule for "Inheritance tree of classes should not be too
		 deep" (just an example) -->
	<sonar.issue.ignore.multicriteria.e11.ruleKey>
	  java:S110
	</sonar.issue.ignore.multicriteria.e11.ruleKey>
	<sonar.issue.ignore.multicriteria.e11.resourceKey>
	  **/*.java
	</sonar.issue.ignore.multicriteria.e11.resourceKey>
	
	<!-- Disable rule for "Local variable and method parameter names should
		 comply with a naming convention" (just an example) -->
	<sonar.issue.ignore.multicriteria.e12.ruleKey>
	  java:S117
	</sonar.issue.ignore.multicriteria.e12.ruleKey>
	<sonar.issue.ignore.multicriteria.e12.resourceKey>
	  **/StudentSwingView.java
	</sonar.issue.ignore.multicriteria.e12.resourceKey>
	
	<!-- Disable rule for "Tests should include assertions" 
	     SonarQube is not aware of AssertJ Swing -->
	<sonar.issue.ignore.multicriteria.e13.ruleKey>
	  java:S2699
	</sonar.issue.ignore.multicriteria.e13.ruleKey>
	<sonar.issue.ignore.multicriteria.e13.resourceKey>
	  **/StudentSwingViewTest.java
	</sonar.issue.ignore.multicriteria.e13.resourceKey>
	
	<!-- Anche se le escludiamo da Jacoco, SonarQube continua a considerarle
		 nella copertura del codice. Occorre quindi escluderle anche da
		 SonarQube. -->
	<sonar.coverage.exclusions>
	  **/model/*.*,
	  **/SchoolSwingApp.*
	</sonar.coverage.exclusions>
	
	<!-- Independently from code coverage, SonarQube only counts and shows the reports generated by
		 surefire , that is, unit tests. If we want to make SonarQube keep track of integration tests as well,
	     we must set the following property explicitly in the POM, specifying the directories of reports of
		 surefire and failsafe -->
	<sonar.junit.reportPaths>
	  ${project.build.directory}/surefire-reports,
	  ${project.build.directory}/failsafe-reports
	 </sonar.junit.reportPaths>
  </properties>
  
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>${junit.version}</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.assertj</groupId>
	  <artifactId>assertj-swing-junit</artifactId>
	  <version>${assertj.swing.version}</version>
	  <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>${mockito.version}</version>
      <scope>test</scope>
    </dependency>
    <dependency>
	  <groupId>org.mongodb</groupId>
	  <artifactId>mongo-java-driver</artifactId>
	  <version>${mongo.version}</version>
	</dependency>
	<dependency>
	  <!-- required to see Mongo Java Driver logs -->
	  <!-- The logging dependency is required to see the logs of communications with the database -->
	  <groupId>ch.qos.logback</groupId>
	  <artifactId>logback-classic</artifactId>
	  <version>${logback.version}</version>
	</dependency>
	<dependency>
	  <groupId>de.bwaldvogel</groupId>
	  <artifactId>mongo-java-server</artifactId>
	  <version>${mongojavaserver.version}</version>
	  <scope>test</scope>
	</dependency>
	<dependency>
	  <groupId>org.testcontainers</groupId>
	  <artifactId>testcontainers</artifactId>
	  <version>${testcontainers.version}</version>
	  <scope>test</scope>
	</dependency>
	<dependency>
	  <groupId>org.testcontainers</groupId>
	  <artifactId>mongodb</artifactId>
	  <version>${testcontainers.version}</version>
	  <scope>test</scope>
	</dependency>
	<dependency>
	  <!-- A Java command line parser. Picocli allows us to specify the command line arguments
 		   by defining fields in a Java class with its annotations. Picocli initializes such annotated
		   fields from the command line arguments, converting the input to strongly typed values in the fields 
	  -->
	  <groupId>info.picocli</groupId>
	  <artifactId>picocli</artifactId>
	  <version>${picocli.version}</version>
	</dependency>
  </dependencies>
  
  <build>
  	<pluginManagement>
	  <plugins>
		<plugin>
		  <groupId>org.sonarsource.scanner.maven</groupId>
		  <artifactId>sonar-maven-plugin</artifactId>
		  <version>${sonar.maven.version}</version>
		</plugin>
	  </plugins>
	</pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
		<artifactId>build-helper-maven-plugin</artifactId>
		<version>${buildhelper.version}</version>
		<executions>
		  <execution>
		    <id>add-test-source</id>
			<phase>generate-test-sources</phase>
			<goals>
			  <goal>add-test-source</goal>
			</goals>
			<configuration>
			  <sources>
			    <source>src/it/java</source>
			    <source>src/e2e/java</source>
			  </sources>
			</configuration>
		  </execution>
		</executions>
      </plugin>
      <plugin>
	    <groupId>org.apache.maven.plugins</groupId>
		<artifactId>maven-failsafe-plugin</artifactId>
		<version>${failsafe.version}</version>
		<configuration>
		  <systemPropertyVariables>
		    <mongo.port>${mongo.mapped.port}</mongo.port>
		  </systemPropertyVariables>
		</configuration>
		<executions>
		  <execution>
		    <id>default-it</id>
		    <goals>
			  <goal>integration-test</goal>
			  <goal>verify</goal>
			</goals>
		  </execution>
		  <execution>
		    <id>e2e-test</id>
		    <goals>
		      <goal>integration-test</goal>
		      <goal>verify</goal>
		    </goals>
		    <configuration>
		      <excludes>
		        <exclude>**/*IT.java</exclude>
		      </excludes>
		      <includes>
		        <include>**/*E"E.java</include>
		      </includes>
		    </configuration>
		  </execution>
		</executions>
	  </plugin>
	  <!-- when running the Maven build, the container must be started directly during the build, 
	       before running integration tests (or at least, before this very integration test case).
	       Similarly, the container must be stopped during the build after integration tests are run,
	       independently from whether they succeeded or not.
	       
		   To achieve that, all we need to do is to configure the docker-maven-plugin binding its 
		   start and stop goals to pre-integration-test and post-integration-test phases, respectively.
		   Moreover, we configure the image for MongoDB. -->
	  <plugin>
	    <groupId>io.fabric8</groupId>
		<artifactId>docker-maven-plugin</artifactId>
		<version>${docker.version}</version>
		<configuration>
		  <images>
		    <image>
			  <name>mongo:4.0.5</name>
			  <run>
			    <ports>
			      <!-- mongo.mapped.port consente di allocare dinamicamente la porta dell'host
			           in modo da evitare conflitti, cosa che può accadere se utilizziamo una
			           porta fissa -->
				  <port>mongo.mapped.port:27017</port>
				</ports>
			  </run>
			</image>
		  </images>
		</configuration>
		<executions>
		  <execution>
		    <id>docker-start</id>
			<phase>pre-integration-test</phase>
			<goals>
			  <goal>start</goal>
			</goals>
		  </execution>
		  <execution>
		    <id>docker-stop</id>
		    <phase>post-integration-test</phase>
		    <goals>
		      <goal>stop</goal>
		    </goals>
		  </execution>
	    </executions>
	  </plugin>
    </plugins>
  </build>
  
  <profiles>
    <profile>
      <id>jacoco</id>
      <build>
        <plugins>
          <plugin>
		    <groupId>org.jacoco</groupId>
			<artifactId>jacoco-maven-plugin</artifactId>
			<version>${jacoco.version}</version>
			<configuration>
			  <excludes>
			    <exclude>**/model/*.*</exclude>
				<exclude>**/SchoolSwingApp.*</exclude>
			  </excludes>
			</configuration>
			<executions>
			  <execution>
				<goals>
				  <goal>prepare-agent</goal>
				  <!-- A few releases ago, SonarQube stopped inspecting the JaCoCo binary .exec files to collect
					   code coverage. It now inspects the JaCoCo’s XML coverage report, that is why it is crucial
					   to enable the goal report of the JaCoCo Maven plugin. -->
				  <goal>report</goal>
				</goals>
			  </execution>
			</executions>
		  </plugin>
        </plugins>
      </build>
    </profile>
  </profiles>
  
</project>
